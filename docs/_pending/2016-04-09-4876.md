---
title: "Tvheadend y aceleración HW Intel Quick Sync Video"
date: "2016-04-09"
categories: 
  - "apuntes"
  - "gentoo"
  - "linux"
  - "media-center"
  - "qsv"
  - "vaapi"
tags: 
  - "aceleracion"
  - "qsv"
  - "quicksync-video"
  - "transcodificacion"
  - "tvheadend"
---

En este apunte explico cómo conseguir que [**Tvheadend**](https://tvheadend.org/) use las capacidades de **transcodificación (encode y decode) por Hardware ofrecidas por [Intel Quick Sync Video](https://en.wikipedia.org/wiki/Intel_Quick_Sync_Video)** (por ejemplo en sus NUC's). Permite que los **streams de video** utilicen mucho **menos ancho de banda**. Pensaba **que NO me iba a hacer falta** debido a mi caso de uso (Tvheadend para [ver canales iptv](https://www.luispa.com/archivos/4571)  en un entorno sin problemas de ancho de banda, [router Linux + Fibra](https://www.luispa.com/archivos/266) y clientes [raspberry con Kodi](https://www.luispa.com/archivos/1284) por cable Ethernet).

**Bueno, pues resulta que sí que necesito transcodificar**, tengo dos casos: el primero es cuando uso un **cliente Móvil** (teléfono, tableta) por la WiFi casera y el segundo si quiero **acceder por internet** para ver la TV de mi casa (ejemplo: en vacaciones).  Si intento enviar un canal HD (+10Mbps) vía WiFi o Internet a un móvil o una tableta funciona pero con microcortes o retrasos o pérdidas de tráfico, en definitiva inestabilidad.

 

[![Transcoding](https://www.luispa.com/wp-content/uploads/2016/07/Transcoding-300x235.jpg)](https://www.luispa.com/wp-content/uploads/2016/07/Transcoding.jpg)

 

Tvheadend soporta transcodificación, tanto software como hardware. La primera es fácil de activar y funciona, pero si le exiges que tenga buena calidad te va a **fundir la CPU** (100% de consumo) y tendrás microcortes, retrasos, pérdidas de tráfico, inestabilidad. Hay dos opciones 1) transcodificación software sin demasiadas exigencias o 2) transcodificación HW exigiendo buena calidad y mínimo consumo de CPU.

Nota: En mi caso estoy haciendo las pruebas con un NUC D54250WYK, cuenta con CPU Intel Core i5-4250U y GPU (reportada por `lspci`) `Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 09)`, pero este apunte aplica a cualquier ordenador que use los chips de intel de diferentes generaciones (ojo, algunas pueden no soportar lo que aquí se describe, consulta los enlaces al final de este apunte).

## Cómo usar Intel QSV en Linux y en Tvheadend

 

#### **Que Linux use aceleración por HW (QSV): objetivo cumplido**

El primer objetivo que me planteé fue que el Linux (gentoo) fuese capaz de acceder al Hardware gráfico (QSV) del Intel NUC. Hay que instalar paquetes estándar (Gentoo en mi caso) y preparar el Kernel. Opcional recomiendo instalar X11 para verificar que se consume QSV en entorno gráfico cuando ves por ejemplo una peli. En cualquier caso también funciona en modo Headless (sin X11), es decir, puedes usar ffmpeg para codificar o de-codificar (transcodificar).

- **Soporte nativo en el Kernel, Sistema Operativo, FFMPEG accediendo a QSV vía VAAPI**
    - Ventaja: Funciona.
    - Está documentado en "[Soporte nativo de Intel QSV+VAAPI en Linux](https://www.luispa.com/archivos/4876#linuxnativo)"
    - Nota1: Quick Sync está soportado por el [VA API](https://en.wikipedia.org/wiki/VA_API "VA API"), tanto para encoding como decoding, así ques VAAPI es el método preferido para poder "consumir" dicho Hardware (QSV).
    - Nota2: FFMPEG, uso la nueva 3.1 que ha empezado a soportar VAAPI hace poco tiempo.

 

#### **Que Tvheadend use aceleración por HW (QSV): Work In Progress**

Esto es otra historia,  el segundo objetivo consiste en compilar Tvheadend para que acceda al Hardware del Intel NUC (QSV) y sea capaz de usar la aceleración HW. Por desgracia a fecha de Julio de 2016 todavía no es fácil pero se supone que llegará.

Por lo que he podido investigar tenemos dos opciones:

- **Soporte nativo de vaapi en Tvheadend (Solución ideal)**
    - Ventaja: Mucho más sencillo, estándar y compatible con cualquier distro/kernel.
    - Desventaja: Todavía no existe ([aunque ya hay petición oficial #3831 en Tvheadend, no te cortes y pídelo tú también](https://tvheadend.org/issues/3831)) --- Actualización (Feb 2018: [issue 4443 es más moderno](https://tvheadend.org/issues/4443)
    [](https://tvheadend.org/issues/4443)- [Lo iré documentando en la sección "](https://tvheadend.org/issues/4443)[Tvheadend con soporte nativo VAAPI](https://www.luispa.com/archivos/4876#tvhnativo)".
- **Soporte meditante el SDK de Quick Sync de Intel y un Kernel concreto parcheado (no me gusta)**
    - Ventaja: Funciona, aunque por lo que he visto no me convence...
    - Desventaja: obliga a usar una Distro+Kernel concretos,
    - Desventaja: Por lo que he visto en los foros es complicado de montar.
    - Desventaja: Condena al NUC a este role específico (tvheadend).
    - He documentado esta opción en la sección "[Tvheadend con SDK Quick Sync](https://www.luispa.com/archivos/4876#tvhsdk)".

 

 

### Soporte nativo de Intel QSV+VAAPI en Linux (Gentoo)

Lo primero que voy a hacer es preparar el sistema para que funcione Xorg y  la aceleración de video. Te recomiendo que empieces por aquí, aunque no necesites X11 para Tvheadend más tarde, es una forma de quitarme muchas dudas si luego las cosas NO funcionan, es decir prefiero conseguir llegar a la primera "base", dejar X11 funcionando, comprobar que mi tarjeta i965 funciona correctamente y que se consume por Hardware de forma correcta. Nota: he usado esta fuente [https://wiki.gentoo.org/wiki/Intel](https://wiki.gentoo.org/wiki/Intel), [https://wiki.gentoo.org/wiki/VAAPI](https://wiki.gentoo.org/wiki/VAAPI). Mi segunda _base_ será confirmar que incluso sin X11 me funcionan los comandos que comprueban que el hardware GPU es accesible.

- Configuro VIDEO\_CARDS y USE (Habilito el HW decoding H264 y VAAPI)

\# grep VIDEO\_CARDS /etc/portage/make.conf
VIDEO\_CARDS="intel i965"

# grep USE /etc/portage/make.conf
USE="X -bindist -gnome -kde  aes avx avx2 fma3 mmx mmxext popcnt sse sse2 sse3 sse4\_1 sse4\_2 ssse3 g45-h264 vaapi"

- Accept Keywords

tv ~ # cat /etc/portage/package.accept\_keywords
:
~media-tv/tvheadend-9999 \*\*
media-video/ffmpeg ~amd64

~x11-libs/libva-9999 \*\*
~x11-libs/libva-intel-driver-9999 \*\*

media-video/mpv ~amd64

- Licencia fdk-aac

tv ~ # cat /etc/portage/package.license
=media-libs/fdk-aac-0.1.3 FraunhoferFDK

- USE flags para FFMPEG y para Tvheadend

tv ~ # cat /etc/portage/package.use/ffmpeg
media-plugins/alsa-plugins pulseaudio
x11-libs/libva drm X -egl opengl -vdpau -wayland
media-video/ffmpeg X alsa bzip2 encode gpl hardcoded-tables iconv mp3 network openal opengl postproc pulseaudio sdl threads truetype vaapi -vdpau vorbis x264 x265 xcb xvid zlib static-libs amr amrenc cpudetection faac fdk

tv ~ # cat /etc/portage/package.use/tvheadend
# Tvheadend
media-tv/tvheadend cwc dbus dvb dvbscan timeshift zlib -avahi -capmt -constcw ffmpeg -hdhomerun -imagecache -inotify iptv -libav -satip uriparser xmltv
# X
x11-libs/libxcb xkb
# VLC
sys-libs/zlib minizip

- Unmask FFMPEG (para que compile la 3.x)

tv ~# cat /etc/portage/package.unmask/ffmpeg
media-video/ffmpeg

- Me aseguro de tener preparado el Kernel según comenta en este enlace https://wiki.gentoo.org/wiki/Intel (yo uso Kernel 4.x)

Processor type and features  --->
    \[\*\] MTRR (Memory Type Range Register) support

```
 Device Drivers  --->
            Graphics support  --->
                <*> /dev/agpgart (AGP Support)  --->
                    --- /dev/agpgart (AGP Support)
                    < >   AMD Opteron/Athlon64 on-CPU GART support
                    -*- Intel 440LX/BX/GX, I8xx and E7x05 chipset support
                    < >   SiS chipset support
                    < >   VIA chipset support
                [ ] VGA Arbitration
                [ ] Laptop Hybrid Graphics - GPU switching support
                <*> Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)  --->
                    --- Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)
                    [*]   Enable legacy fbdev support for your modesetting driver
                [ ] Allow to specify an EDID data set instead of probing for it
                    I2C encoder or helper chips  --->
                < > 3dfx Banshee/Voodoo3+
                < > ATI Rage 128
                < > ATI Radeon
                < > AMD GPU
                < > Nouveau (NVIDIA) cards
                < > Intel I810
                <*> Intel 8xx/9xx/G3x/G4x/HD Graphics
                [ ]   Enable preliminary support for prerelease Intel hardware by default
                < > Matrox g200/g400
                < > SiS video cards
                < > Via unichrome video cards
                < > Savage video cards
                < > Virtual GEM provider
                < > DRM driver for VMware Virtual GPU
                < > Intel GMA5/600 KMS Framebuffer
                < > DisplayLink
                < > AST server chips
                < > Kernel modesetting driver for MGA G200 server engines
                < > Cirrus driver for QEMU emulated device
                < > QXL virtual GPU
                < > DRM Support for bochs dispi vga interface (qemu stdvga)
                    Display Panels  ---- 
                    Display Interface Bridges  ----
                    Frame buffer Devices  --->
                -*- Backlight & LCD device support  --->
                    Console display driver support  --->
                [*] Bootup logo  --->
```

Rearranco el equipo y continúo.

- Fuerzo que se recompile todo, con los **nuevos flags de USE**, las librerías de **libva y ffmpeg**

tv ~ # emerge -DuvN system world ffmpeg

- Compilo Xorg-server

tv ~ # emerge -v xorg-server

- Arranco Xorg

tv ~ # startx

- Desde la CONSOLA X11 ejecuto 'vainfo'

(( No hace falta, pero podrías necesitar hacer: export LIBVA\_DRIVER\_NAME=i965 ))
# vainfo
libva info: VA-API version 0.39.2
libva info: va\_getDriverName() returns 0
libva info: Trying to open /usr/lib64/va/drivers/i965\_drv\_video.so
libva info: Found init function \_\_vaDriverInit\_0\_39
libva info: va\_openDriver() returns 0
vainfo: VA-API version: 0.39 (libva 1.7.2.pre1)
vainfo: Driver version: Intel i965 driver for Intel(R) Broadwell - 1.7.2.pre1 (1.7.0-53-gbcde10d)
vainfo: Supported profile and entrypoints
      VAProfileMPEG2Simple            :    VAEntrypointVLD
      VAProfileMPEG2Simple            :    VAEntrypointEncSlice
      VAProfileMPEG2Main              :    VAEntrypointVLD
      VAProfileMPEG2Main              :    VAEntrypointEncSlice
      VAProfileH264ConstrainedBaseline:    VAEntrypointVLD
      VAProfileH264ConstrainedBaseline:    VAEntrypointEncSlice
      VAProfileH264Main               :    VAEntrypointVLD
      VAProfileH264Main               :    VAEntrypointEncSlice
      VAProfileH264High               :    VAEntrypointVLD
      VAProfileH264High               :    VAEntrypointEncSlice
      VAProfileH264MultiviewHigh      :    VAEntrypointVLD
      VAProfileH264MultiviewHigh      :    VAEntrypointEncSlice
      VAProfileH264StereoHigh         :    VAEntrypointVLD
      VAProfileH264StereoHigh         :    VAEntrypointEncSlice
      VAProfileVC1Simple              :    VAEntrypointVLD
      VAProfileVC1Main                :    VAEntrypointVLD
      VAProfileVC1Advanced            :    VAEntrypointVLD
      VAProfileNone                   :    VAEntrypointVideoProc
      VAProfileJPEGBaseline           :    VAEntrypointVLD
      VAProfileVP8Version0\_3          :    VAEntrypointVLD

- Para probar la aceleración instalo MPV

marte ~ # emerge -v mpv

- Ejecuto MPV e intento abrir un stream de video. Todo esto en la consola GUI del servidor.

marte ~ # gpasswd -a luis video
marte ~$ mpv

 

**Comprobar que FFMPEG consume la GPU con VAAPI**

- Vamos a por la segunda \*base\*, comprobar que `ffmpeg` es capaz de realizar una transcodificación delegándoselo a la GPU. Para comprobarlo necesitas instalar una herramienta de intel llamada `intel_gpu_tool`

marte ~ # emerge -v intel-gpu-tools

-  A partir de aquí NO necesitamos X11, es decir, trabajamos en modo headless. En mi ejemplo he usado una película ripeada a 1080FullHD con H264 y audio AC3. El objetivo es transcodificarla pero sobre todo que lo haga la GPU. El soporte de VAAPI en FFMPEG se incluyo hace muy poco tiempo.

marte ~ # ffmpeg -vaapi\_device /dev/dri/renderD128 -i CA.mpeg -vf 'format=nv12,hwupload' -c:v h264\_vaapi output.mkv

[![ffmpegGPUuse](https://www.luispa.com/wp-content/uploads/2016/07/ffmpegGPUuse-1024x492.png)](https://www.luispa.com/wp-content/uploads/2016/07/ffmpegGPUuse.png)

- Aquí viene la verdadera comprobación, ejecuto `intel_gpu_tool` en otra sesión de terminal para comprobar que **efectivamente se está consumiendo la GPU (Hardware gráfico de Intel QSV)**

marte ~ # intel\_gpu\_top

[![intel_gpu_tool](https://www.luispa.com/wp-content/uploads/2016/07/intel_gpu_tool-1024x534.png)](https://www.luispa.com/wp-content/uploads/2016/07/intel_gpu_tool.png)Deberías ver cómo las barras van indicando el consumo de la GPU, objetivo cumplido. Nuestro Linux es capaz de usar los servicios hardware Quick Sync Video de la tarjeta Intel.

 

### Soporte nativo de Intel QSV+VAAPI en Linux (Ubuntu 16.04 LTS)

En esta sección describo cómo he instalado FFMPEG + VAAPI para un Servidor (headless).

Instalación de ffmpeg (fuente: https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu). Otros enlaces de interes: https://gist.github.com/Brainiarc7/95c9338a737aa36d9bb2931bed379219 , https://tvheadend.org/boards/5/topics/22670

PENDIENTE DE TERMINAR !!

 

### Tvheadend con soporte nativo VAAPI (Work in Progress)

 

**Esta es la sección buena, la opción que queremos que funcione, aunque todavía no lo hace :-(**

El objetivo aquí es sencillo, que Tvheadend incorpore el soporte de forma nativa para acceder a QSV **mediante VAAPI directamente**, recuerda que QSV - Intel QuickSync Video - permite usar las capacidades Hardware de procesamiento multimedia de la tarjeta fráfica de los procesadores Intel y la clave aquí es cómo acceder a dicho Hardware, en concreto cómo acceder al device driver. El método **limpio y sencillo** que no requiere tocar el kernel ni usar entornos cerrados de desarrollo es mediante VA API y eso es precisamente lo que necesitamos en Tvheadend, soporte del [VA API](https://en.wikipedia.org/wiki/Video_Acceleration_API) directo (**V**ideo **A**cceleration **API**). En FFMPEG ya está hecho, soporta usar VA API, pero... nos falta que Tvheadend lo soporte.

Para conseguirlo es necesario que los desarrolladores de Tvheadend modifiquen el código. Parece que no es demasiado complicado pero obviamente tienen muchas peticiones y tendrán que priorizar. Si tienes un procesador Intel con una tarjeta gráfica embebida de las soportadas [te invito a registrarte en Tvheadend y pidas en este hilo #3831 que lo implementen](https://tvheadend.org/issues/3831), como todo, cuantos más lo pidan mejor :-)

Nota: A paritr de aquí y hasta el final de esta sección sobre Tvheadend y VAAPI está "**Work in Progress (Julio 2016)**", es decir que iré añadiendo pruebas y documentación...

Nota: FFmpeg [puede usar QSV](https://www.ffmpeg.org/general.html#Intel-QuickSync-Video) para realizar **codificación** y **decodificación** de **múltiples códex** en **hardware**. Para poder usar QSV Tvheadend debe linkarse contra el **libmfx dispatcher** y este a su vez  se encarga de cargar las librerías de de-codificación (creo que son las libva\*). Este dispatcher es un proyecto open source disponible en [https://github.com/lu-zero/mfx\_dispatch.git](https://github.com/lu-zero/mfx_dispatch.git).

El soporte de VAAPI en Tvheadend no está completo de momento, usas el pix\_fmt incorrecto (esto es sencillo de arreglar) y no configura el dispositivo DRM. Lo dicho, necesita que un desarrollador lo arregle.

Para entender cómo hacer pruebas con esta versión en desarrollo te recomiendo leer la sección siguiente "Compilación manual de Tvheadend" y luego hasta llegar las "Pruebas Agosto 2016" donde describo lo último que estoy probando (una branch especial de 'lekma')

## Compilación manual de Tvheadend

En esta sección documento cómo estoy compilando [Tvheadend **"a pelo"** desde GitHub](https://github.com/tvheadend/tvheadend), en vez de usar `emerge` porque me permite ir haciendo pruebas con las distintas liberías (elegir usar las del sistema o las de SDK) y además estar seguro de usar el **último código de Tvheadend**.

Notar que utilizo  **`configure`** con la opción **`--enable-qsv`** que provoca que se instalen ffmpeg con las opciones que necesitamos (`--enable-libx264 --enable-libx265 **--enable-vaapi** **--enable-libmfx**`), entre otras.

\# mkdir /root/github\_tvh
# cd github\_tvh
# git clone https://github.com/tvheadend/tvheadend.git
# cd tvheadend
# pwd
/root/github\_tvh/tvheadend
# ./configure --prefix=/usr --build=x86\_64-pc-linux-gnu --host=x86\_64-pc-linux-gnu --mandir=/usr/share/man --infodir=/usr/share/info \\
  --datadir=/usr/share --sysconfdir=/etc --localstatedir=/var/lib --libdir=/usr/lib64 --prefix=/usr --datadir=/usr/share --enable-qsv
Checking support/features
  checking for cc execinfo.h ...                    ok
  checking for cc -mmmx ...                         ok
  checking for cc -msse2 ...                        ok
  checking for cc -Wunused-result ...               ok
  checking for cc getloadavg ...                    ok
  checking for cc atomic64 ...                      ok
  checking for cc atomic\_time\_t ...                 ok
  checking for cc lockowner ...                     ok
  checking for cc qsort\_r ...                       ok
  checking for cc stime ...                         ok
  checking for cc gmtoff ...                        ok
  checking for cc recvmmsg ...                      ok
  checking for cc sendmmsg ...                      ok
  checking for cc libiconv ...                      fail
  checking for cc libdvben50221 ...                 ok
  checking for cc ifnames ...                       ok
  checking for py module gzip ...                   ok
  checking for pkg-config ...                       ok
  checking for xgettext ...                         ok
  checking for msgmerge ...                         ok
  checking for gzip ...                             ok
  checking for bzip2 ...                            ok
  checking for pkg openssl  ...                     ok (detected 1.0.2h)
  checking for cc linux/dvb/version.h ...           ok
  checking for pkg zlib  ...                        ok (detected 1.2.8)
  checking for pkg liburiparser  ...                ok (detected 0.8.0)
  checking for pkg avahi-client  ...                ok (detected 0.6.32)
  checking for cmake ...                            ok
  checking for cc -lstdc++ ...                      ok
  checking for cc nvEncodeAPI.h ...                 fail
  checking for autoreconf ...                       ok
  checking for libtool ...                          ok
  checking for libtoolize ...                       ok
  checking for cc -lstdc++ ...                      ok
  checking for pkg libva >=0.38.0 ...               ok (detected 0.39.2)
  checking for pkg libva-x11 >=0.38.0 ...           ok (detected 0.39.2)
  checking for pkg libva-drm >=0.38.0 ...           ok (detected 0.39.2)
  checking for cc sys/inotify.h ...                 ok
  fetching dvb-scan files ...                       ok
  checking for pkg dbus-1  ...                      ok (detected 1.10.8)

Compiler:
  Using C compiler:                        cc
  Using LD flags:                           -ldvben50221 -ldvbapi -lucsi
  Build for arch:                          x86\_64

Binaries:
  Using PYTHON:                            python
  Using GZIP:                              gzip
  Using BZIP2:                             bzip2

Options:
  pie                                      yes
  ccdebug                                  no
  cwc                                      yes
  capmt                                    yes
  constcw                                  yes
  linuxdvb                                 yes
  satip\_server                             yes
  satip\_client                             yes
  hdhomerun\_client                         yes
  hdhomerun\_static                         yes
  iptv                                     yes
  tsfile                                   yes
  dvbscan                                  yes
  timeshift                                yes
  trace                                    yes
  imagecache                               yes
  avahi                                    yes
  zlib                                     yes
  libav                                    yes
  ffmpeg\_static                            yes
  libx264                                  yes
  libx264\_static                           yes
  libx265                                  yes
  libx265\_static                           yes
  libvpx                                   yes
  libvpx\_static                            yes
  libtheora                                yes
  libtheora\_static                         yes
  libvorbis                                yes
  libvorbis\_static                         yes
  libfdkaac                                yes
  libfdkaac\_static                         yes
  nvenc                                    no
  qsv                                      yes
  libmfx\_static                            yes
  inotify                                  yes
  epoll                                    yes
  uriparser                                yes
  ccache                                   no
  tvhcsa                                   yes
  bundle                                   no
  dvbcsa                                   no
  dvben50221                               yes
  kqueue                                   no
  dbus\_1                                   yes
  android                                  no
  tsdebug                                  no
  gtimer\_check                             no
  slow\_memoryinfo                          no
  libsystemd\_daemon                        no
  bintray\_cache                            yes
  execinfo                                 yes
  mmx                                      yes
  sse2                                     yes
  W\_unused\_result                          yes
  getloadavg                               yes
  atomic64                                 yes
  atomic\_time\_t                            yes
  lockowner                                yes
  qsort\_r                                  yes
  stime                                    yes
  gmtoff                                   yes
  recvmmsg                                 yes
  sendmmsg                                 yes
  libdvben50221                            yes
  ifnames                                  yes
  py\_gzip                                  yes
  bin\_pkg\_config                           yes
  bin\_xgettext                             yes
  bin\_msgmerge                             yes
  bin\_gzip                                 yes
  bin\_bzip2                                yes
  ssl                                      yes
  linuxdvbapi                              yes
  upnp                                     yes
  bin\_cmake                                yes
  stdcpp                                   yes
  libogg\_static                            yes
  bin\_autoreconf                           yes
  bin\_libtool                              yes
  bin\_libtoolize                           yes
  vaapi                                    yes
  inotify\_h                                yes
  linuxdvb\_ca                              yes
  mpegts                                   yes
  mpegts\_dvb                               yes

Packages:
  openssl                                  1.0.2h
  zlib                                     1.2.8
  liburiparser                             0.8.0
  avahi-client                             0.6.32
  libva                                    0.39.2
  libva-x11                                0.39.2
  libva-drm                                0.39.2
  dbus-1                                   1.10.8

Installation paths:
  Prefix:                                  /usr
  Binaries:                                ${prefix}/bin
  Libraries:                               /usr/lib64
  Data files:                              /usr/share
  Man pages:                               /usr/share/man

Final Binary:
  /root/github\_tvh/tvheadend/build.linux/tvheadend

Tvheadend Data Directory:
  /usr/share/tvheadend
# make
Se baja y compila yasm 1.3.0
Se baja y compila x264 desde el proyecto videolan
Se baja y compila x265 desde el proyecto videolan
Se baja y compila libvpx
Se baja y compila libogg
Se baja y compila libtheora
Se baja y compila libvorbis
Se baja y compila fdk-aac
Se baja y compila mfx\_dispatch
Se baja y compila el ffmpeg (3.1)
FFMEG LO COMPILA CON ESTAS OPCIONES:
./configure --prefix=/ffmpeg --enable-static --disable-shared \\
    --disable-all \\
    --enable-gpl \\
    --extra-cflags="-I/root/git/tvheadend/build.linux/ffmpeg/build/ffmpeg/include -fPIE" \\
    --extra-libs="-L/root/git/tvheadend/build.linux/ffmpeg/build/ffmpeg/lib -ldl" \\
    --pkg-config="/root/git/tvheadend/support/pkg-config.ffmpeg" \\
    --enable-avutil --enable-avcodec --enable-avformat --enable-swscale --enable-avresample --enable-swresample --enable-avfilter \\
    --enable-libx264 --enable-libx265 --enable-libvpx --enable-libtheora --enable-libvorbis --enable-libfdk-aac --enable-vaapi --enable-libmfx --enable-nonfree \\
    --enable-protocol=file \\
    --enable-decoder=mpeg2video --enable-decoder=mp2 --enable-decoder=aac --enable-decoder=vorbis --enable-decoder=ac3 --enable-decoder=eac3 --enable-decoder=aac\_latm --enable-decoder=h264 --enable-decoder=hevc --enable-decoder=libvorbis --enable-decoder=mpeg2\_qsv --enable-decoder=h264\_qsv --enable-decoder=hevc\_qsv \\
    --enable-encoder=mpeg2video --enable-encoder=mp2 --enable-encoder=aac --enable-encoder=vorbis --enable-encoder=libx264 --enable-encoder=libx265 --enable-encoder=libvpx\_vp8 --enable-encoder=libvpx\_vp9 --enable-encoder=libtheora --enable-encoder=libvorbis --enable-encoder=libfdk\_aac --enable-encoder=h264\_vaapi --enable-encoder=hevc\_vaapi --enable-encoder=mpeg2\_qsv --enable-encoder=h264\_qsv --enable-encoder=hevc\_qsv \\
    --enable-muxer=mpegts --enable-muxer=mpeg2dvd --enable-muxer=matroska --enable-muxer=webm --enable-muxer=mp4 --enable-muxer=ogg \\
    --enable-bsf=h264\_mp4toannexb --enable-bsf=hevc\_mp4toannexb \\
    --enable-filter=yadif --enable-filter=scale --enable-filter=null --enable-filter=aresample --enable-filter=anull
Se baja y compila hdhomerun
Cuando termina deja el ejecutable en ./build.linux/

Como digo, termina y deja el ejecutable en build.linux. El siguiente paso es instalarlo en tu sistema:

\# make install

En mi caso (ver los argumentos de `./configure`) dejo el ejecutable en `/usr/bin`, es decir en el mismo sitio donde lo deja `emerge` en Gentoo. Si quieres mantener ambos deberías renombrar uno de los dos o configurar que la versión manual se instale en otro sitio.

**Librerías FFMPEG que se Linkan estáticamente al ejecutable**

En la compilación **manual de Tvheadend** estamos creando un **ejecutable con muchas librerías linkadas estáticamente dentro del mismo**, es decir **no utiliza esas librerias de tu sistema operativo sino que compila su propia copia de FFMPEG y sus librerías para linkarlas al ejecutable.** No me gusta demasiado, pero la ventaja es que evita conflictos y que podrías tener varias versiones de Tvheadend para hacer pruebas. Estas son las dependencias de FFMpeg que linka estáticamente (fecha Julio 2016):

marte tvheadend # cd build.linux/ffmpeg/
marte ffmpeg # ls -al
total 20400
drwxr-xr-x 13 root root    4096 jul  5 20:51 .
drwxr-xr-x  5 root root    4096 jul  5 20:56 ..
-rw-r--r--  1 root root  112281 jul  5 20:51 9f4a84d73fb73d430f07a80cea3688c424439f6a.tar.gz
drwxr-xr-x  3 root root    4096 jul  5 20:46 build
drwxr-xr-x 15 1000 1000    4096 jul  5 20:51 fdk-aac-0.1.4
-rw-r--r--  1 root root 1986515 mar 11  2015 fdk-aac-0.1.4.tar.gz
drwx------ 16 1000 1000    4096 jul  5 20:55 ffmpeg-3.1
-rw-r--r--  1 root root 9329359 jun 27 02:26 ffmpeg-3.1.tar.bz2
drwxrwxr-x  7  500  500    4096 jul  5 20:50 libogg-1.3.2
-rw-r--r--  1 root root  550250 may 27  2014 libogg-1.3.2.tar.gz
drwxrwxrwx 11  500  500    4096 jul  5 20:50 libtheora-1.1.1
-rw-r--r--  1 root root 2111877 ene 25  2010 libtheora-1.1.1.tar.gz
drwxr-xr-x 13  501   20    4096 jul  5 20:50 libvorbis-1.3.5
-rw-r--r--  1 root root 1638779 mar  3  2015 libvorbis-1.3.5.tar.gz
drwxr-xr-x 15 root root    4096 jul  5 20:50 libvpx-1.5.0
-rw-r--r--  1 root root 1906571 nov 10  2015 libvpx-1.5.0.tar.bz2
drwxrwxr-x  7 root root    4096 jul  5 20:51 mfx\_dispatch-9f4a84d73fb73d430f07a80cea3688c424439f6a
drwxr-xr-x 10 1000 1000    4096 jul  5 20:47 x264-snapshot-20160502-2245
-rw-r--r--  1 root root  730104 may  2 22:45 x264-snapshot-20160502-2245.tar.bz2
drwxr-xr-x  5 root root    4096 jul  5 20:49 x265\_1.9
-rw-r--r--  1 root root  956101 feb  5 05:20 x265\_1.9.tar.gz
drwxrwxr-x 13 1000 1000    4096 jul  5 20:46 yasm-1.3.0
-rw-r--r--  1 root root 1492156 ago 11  2014 yasm-1.3.0.tar.gz

 

#### Liberías o paquetes que espera encontrar en el Sistema Operativo

Por otro lado hay una serie de apquetes que espera encontrar en el Sistema Operativo (lo indica durante la ejecución de `./configure`)

Packages:
  openssl                                  1.0.2h
  zlib                                     1.2.8
  liburiparser                             0.8.0
  avahi-client                             0.6.32
  libva                                    0.39.2
  libva-x11                                0.39.2
  libva-drm                                0.39.2
  dbus-1                                   1.10.8

Y de ellos el más importante es `libva`

  libva                                    0.39.2
  libva-x11                                0.39.2
  libva-drm                                0.39.2

 

#### Transcodificar por HW

Como comenté al principio de este apunte Tvheadend puede usar libva (vaapi) pero por desgracia luego no funciona. Tras la compilación manual verás múltiples opciones muy interesantes.

[![TransOptions](https://www.luispa.com/wp-content/uploads/2016/07/TransOptions-300x185.png)](https://www.luispa.com/wp-content/uploads/2016/07/TransOptions.png)

Puedo poner la de h264\_vaapi, pero ...

[![TransVAAPI](https://www.luispa.com/wp-content/uploads/2016/07/TransVAAPI-1024x694.png)](https://www.luispa.com/wp-content/uploads/2016/07/TransVAAPI.png)

...pero **de momento nos da este ERROR**

**jul 05 21:22:13 marte tvheadend\[15699\]: libav: mmco: unref short failure
jul 05 21:22:13 marte tvheadend\[15699\]: transcode: 0003: Using preset faster
jul 05 21:22:13 marte tvheadend\[15699\]: libav: Error initializing an internal MFX session
jul 05 21:22:13 marte tvheadend\[15699\]: transcode: 0003: Unable to open h264\_qsv encoder**

 

#### Transcodificar por Software (solución temporal)

Tras varias pruebas he conseguido configurar un perfil de transcodificación (**software**) que funciona **bastante bien** cuando sólo se usa para un único usuario, un único stream y sobre todo "en casos especiales", por ejemplo ver la TV desde una tablet cuando no queda más remedio o para verlo conectado por internet. OJo!, es **sub-óptimo** y como lo fuerces mucho (varios usuarios) te empezará a fallar.

Desde mi punto de vista es una solución **TEMPORAL hasta que Tvheadend soporte FFMPEG con VAAPI**.

[![TransSW](https://www.luispa.com/wp-content/uploads/2016/07/TransSW-300x283.png)](https://www.luispa.com/wp-content/uploads/2016/07/TransSW.png)

A continuación podemos ver un gráfico con el consumo de CPU utilizando la **transcodificación Software "veryfast", 720 bps video y 64bps audio**:. Como se puede ver en la parte superior izquierda, la herramienta intel\_gpu\_tool indica que NO ESTÁ haciendo nada, es decir, funciona todo por Software, como demuestra **htop**, donde aproximadamente el 25% de los vCores están dedicados a transcodificar.

[![transSW](https://www.luispa.com/wp-content/uploads/2016/07/transSW-1024x576.jpg)](https://www.luispa.com/wp-content/uploads/2016/07/transSW.jpg)

El ancho de banda medio consumido es de 750-800Kbps, con ráfaga que llegan a los 2Mbps. En el siguiente gráfico puedes observar en Verde el stream de entrada (un Canal HD) y en Morado el stream de Salida transcodificado.

[![transbw](https://www.luispa.com/wp-content/uploads/2016/07/transbw.png)](https://www.luispa.com/wp-content/uploads/2016/07/transbw.png)

 

 

#### Pruebas Agosto 2016

He descargado el Fork de [**lekma**](https://github.com/lekma/tvheadend) que según el hilo "[Feature #3831: VAAPI Encoding via FFmpeg](https://tvheadend.org/issues/3831#change-19620)" tiene una branch (**codecs**) que podría ser la primera versión que funciona, comentan que ha hecho un trabajo impresionante en la reimplementación del sistema de codecs. Estos son los pasos que he seguido en mi prueba:

Me salvo el antiguo tvheadend añadiendole la versión que tenía compilada:

marte ~ # cd /usr/bin
marte bin # cp tvheadend tvheadend-4.1-2130~g55fec0f-dirty

En un nuevo directorio clono el fork y lo compilo, el proceso es idéntico a lo que describí más arriba.

marte ~ # mkdir /root/github\_tvh\_lekma
marte ~ # cd /root/github\_tvh\_lekma/
marte github\_tvh\_lekma # git clone https://github.com/lekma/tvheadend.git

marte github\_tvh\_lekma # cd tvheadend/

**Importante: cambio al branch "codecs"**

marte github\_tvh\_lekma # git checkout codecs

Compilo (importante usar --enable-vaapi), y luego instalo.

marte tvheadend # ./configure --prefix=/usr --build=x86\_64-pc-linux-gnu --host=x86\_64-pc-linux-gnu --mandir=/usr/share/man --infodir=/usr/share/info \\
  --datadir=/usr/share --sysconfdir=/etc --localstatedir=/var/lib --libdir=/usr/lib64 --prefix=/usr --datadir=/usr/share --enable-vaapi
:
marte tvheadend # make

Me hago una copia del ejecutable antiguo e instalo el nuevo

\# make install
:
marte tvheadend # ls -al /usr/bin/tvheadend\*
-rwxr-xr-x 1 root root 51212936 sep 31 21:58 /usr/bin/tvheadend  <== nuevo 
-rwxr-xr-x 1 root root 49980584 ago 31 21:17 /usr/bin/tvheadend-4.1-2140~gf34fac1
-rwxr-xr-x 1 root root 51212936 ago 31 21:00 /usr/bin/tvheadend-4.1-2202~gf3e5bfb  <== nuevo

Hago un backup de la configuración (aunque al arrancar la nueva versión automáticamente haga su propio backup en /etc/tvheadend/backup).

\# cd /etc
# tar cfz /root/tvheadend-backup.tgz tvheadend/

Arranco el log desde otra sesión:

\# journalctl -f

y rearranco tvheadend

\# systemctl restart tvheadend

Creo 2 nuevos **Codec Profiles** (nuevo en esta branch, 1xVideo y 1xAudio), creo un nuevo **Stream Profile** al que asigno los dos Codec Profiles anteriores. He creado un usuario nuevo al que le asigno el Stream Profile y desde un cliente conecto usando este usuario.

Arranco **intel\_gpu\_top y htop** en dos terminales y conecto desde el cliente. Resultado de los tests:

TESTs: 

/Pendiente de documentar/

Actualizar la versión: Si más adelante van actualizando esta branch, para sincronizar con ella simplemente haz un pull con git y vuelve a compilar

marte tvheadend # git fetch
remote: Counting objects: 68, done.
remote: Total 68 (delta 47), reused 47 (delta 47), pack-reused 21
Unpacking objects: 100% (68/68), done.
From https://github.com/lekma/tvheadend
   f3e5bfb..dbdd70f  codecs     -> origin/codecs
marte tvheadend # git pull
Updating f3e5bfb..dbdd70f
Fast-forward
 src/profile.c                               | 25 -------------------------
 src/transcoding/codec/codecs/libs/libx26x.c |  2 ++
 src/transcoding/codec/codecs/libs/vaapi.c   |  3 +++
 src/transcoding/codec/internals.h           |  1 -
 src/transcoding/codec/profile\_video\_class.c | 20 ++++++++++++++++++++
 src/transcoding/transcode/context.c         |  6 ------
 src/transcoding/transcode/helpers.c         | 32 --------------------------------
 src/transcoding/transcode/internals.h       |  2 +-
 src/transcoding/transcode/video.c           | 52 ++++++++++++++++++++++++++++++++++++++--------------
 9 files changed, 64 insertions(+), 79 deletions(-)
marte tvheadend #

 

 

* * *

* * *

 

### Tvheadend con SDK Quick Sync

He dejado para el final la opción que no me termina de convencer, consiste en usar una distro concreta, con un kernel concreto, instalar el SDK de Intel, parchear el kernel, compilar Tvheadend a mano y **en funciona, aunque puede que no en todos los chips de Intel (parece que Skylake es un ejemplo donde NO funciona)**. Ojo, aunque he conseguido que funcione (la transcodificación por Hardware) veo que sigue consumiendo demasiada CPU y además no consigo que más de un cliente funcionen bien, así que lo dicho, aunque no me convence pero tendré que probarlo más en profundidad algún día.

[![nuc-d54250wyk-mss](https://www.luispa.com/wp-content/uploads/2016/04/nuc-d54250wyk-mss.jpg)](https://www.luispa.com/wp-content/uploads/2016/04/nuc-d54250wyk-mss.jpg)

- Distro.  **CentOS 7.1.1503** (sí, es la versión concreta que Intel llama Gold)
- Entorno de desarrollo. Regístrate como desarrollador al [Intel® Media Server Studio – Community Edition](https://registrationcenter.intel.com/en/forms/?productid=2411%29), descarga la versión **Intel® Media Server Studio for Linux\* (199 MB)** y copiala a tu Distro (se instala en /opt/intel/mediasdk/lib64/\*).
- Parches del Kernel. Los instalará el SDK de Intel
- Tvheadend, compilarlo manulamente.

Para probar esta opción voy a crear un Disco con CentOS 7.1.1503 en una USB para no tocar mi instalación en el NUC. Forzaré que haga boot desde dicha USB mientras realizo las pruebas. Nota: Uso USB's 3.0 o esto sería inmanejable :)

#### Instalo CentOS

- Requisitos - 2xUSB's 3.0,
    - USB1: ISO de Instalación de CentOS
    - USB2: Disco destino donde instalaré CentOS
- Preparo la USB1: ISO de Instalación de CentOS
    - Descargo CentOS 7.1.1503 desde http://mirror.nsc.liu.se/centos-store/7.1.1503/isos/x86\_64/
    - Creo una USB Bootable, la inserto en mi iMac.
    - Averiguo el device con 'df -h' (resultó ser /dev/disk2)
    - Desmonto el volumen: sudo diskutil unmount /dev/disk2s1
    - Grabo el ISO (notar la 'r'): dd if=CentOS-7-x86\_64-DVD-1503-01.iso of=/dev/rdisk2 bs=4194304
- Instalación de CentOS
    - Inserto la USB1 en el NUC (CentOS Install Boot)
    - Inserto la USB2 en el NUC (futuro disco destino)
    - Rearranco el NUC y pulso F10 para elegir desde dónde hacer boot (USB1)
    - Arranco con el ISO de instalación de CentOS
        - Selecciono Install CentOS 7
        - Selecciono como Disco Destino la segunda USB2 (reclamo todo su espacio, particiona automático)
        - Hará una instalación mínima
        - Configuro la Red con IP fija
        - Configuro la contraseña de root y creo un usuario luis
        - Cuando termina, pulso Reiniciar, saco la USB1
- Arranque con USB2 (Donde he instalado CentOS)
    - Al reiniciar pulso F10 para seleccionar la USB2

#### Instalo SDK Intel Media Server Studio

- Uso este PDF como guía
    - https://software.intel.com/sites/default/files/media\_server\_studio\_getting\_started\_guide.pdf
- Instalo dependencias

 # yum install -y lshw
 # yum install -y pciutils
 # yum install -y mesa-dri-drivers
 # yum install -y net-tools

- Verifico que mi HW es compatible

\# lshw
 NUC5i5RYB, con Intel(R) Core(TM) i5-5250U CPU @ 1.60GHz
# lspci -nn -s 00:02.0
 00:02.0 VGA compatible controller \[0300\]: Intel Corporation Broadwell-U Integrated Graphics \[8086:1626\] (rev 09)

- Descargo el SDK Media Server Studio
    - Intel® Media Server Studio – Community Edition Version 2016 (Latest Release)     10 Feb 2016
    - https://registrationcenter.intel.com/en/products/
- NOTA: La IP de mi NUC es 192.168.100.244
    - $ scp MediaServerStudioEssentials2016.tar.gz luis@192.168.100.244:.
- Vuelvo al NUC como usuario normal (luis)

$ tar -xvzf MediaServerStudioEssentials2016.tar.gz
$ cd MediaServerStudioEssentials2016
$ tar xzf SDK2016Production16.4.4.tar.gz
$ cd SDK2016Production16.4.4
$ cd CentOS/
$ tar -xzf install\_scripts\_centos\_16.4.4-47109.tar.gz

- Como "root"

\# cd /home/luis/.../CentOS/
# ./install\_sdk\_UMD\_CentOS.sh
# mkdir /MSS
# chown luis:luis /MSS

- Como usuario normal (luis)

\# su - luis
$ cd MediaServerStudioEssentials2016/SDK2016Production16.4.4/CentOS/
$ cp build\_kernel\_rpm\_CentOS.sh /MSS
$ cd /MSS
$ ./build\_kernel\_rpm\_CentOS.sh

- COMO "root", compruebo que se han generado los RPM's del kernel y los instalo:

\# cd /MSS/rpmbuild/RPMS/x86\_64/
# ls -al
 total 44052
 drwxr-xr-x. 2 luis luis     4096 jul 12 15:00 .
 drwxrwxr-x. 3 luis luis       19 jul 12 14:59 ..
 -rw-rw-r--. 1 luis luis 32273040 jul 12 15:00 kernel-3.10.0-229.1.2.47109.MSSr1.el7.centos.x86\_64.rpm
 -rw-rw-r--. 1 luis luis 10437600 jul 12 15:00 kernel-devel-3.10.0-229.1.2.47109.MSSr1.el7.centos.x86\_64.rpm
 -rw-rw-r--. 1 luis luis  2385132 jul 12 15:00 kernel-headers-3.10.0-229.1.2.47109.MSSr1.el7.centos.x86\_64.rpm

# rpm -Uvh kernel-3.10.0-229.1.2.47109.MSSr1.el7.centos.x86\_64.rpm

#### Rearrancar y comprobar que lo hace con el nuevo kernel

Antes de nada miro en ek Kernel estaba,

\# uname -a
 Linux marte.parchis.org 3.10.0-229.el7.x86\_64 #1 SMP Fri Mar 6 11:36:42 UTC 2015 x86\_64 x86\_64 x86\_64 GNU/Linux

# reboot

# uname -a
 Linux marte.parchis.org 3.10.0-229.1.2.47109.MSSr1.el7.centos.x86\_64 #1 SMP Tue Jul 11 23:24:57 CEST 2016 x86\_64 x86\_64 x86\_64 GNU/Linux
                                    ^^^^^^^^^^^^^^^                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

COMPRUEBO QUE CARGA i915
 \[root@marte ~\]# lsmod | grep 'i915'
 i915                  938476  4
 i2c\_algo\_bit           13413  1 i915
 drm\_kms\_helper         98274  1 i915
 drm                   311336  3 i915,drm\_kms\_helper
 i2c\_core               40325  6 drm,i915,i2c\_i801,i2c\_hid,drm\_kms\_helper,i2c\_algo\_bit
 video                  19263  1 i915

\[root@marte CentOS\]# ls -al /usr/lib64/libva\*
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-drm.so -> libva-drm.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-drm.so.1 -> libva-drm.so.1.9900.0
 -rwxr-xr-x. 1 root root  11344 dic  7  2015 /usr/lib64/libva-drm.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-glx.so -> libva-glx.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-glx.so.1 -> libva-glx.so.1.9900.0
 -rwxr-xr-x. 1 root root  20120 dic  7  2015 /usr/lib64/libva-glx.so.1.9900.0
 lrwxrwxrwx. 1 root root     17 jul 12 14:04 /usr/lib64/libva.so -> libva.so.1.9900.0
 lrwxrwxrwx. 1 root root     17 jul 12 14:04 /usr/lib64/libva.so.1 -> libva.so.1.9900.0
 -rwxr-xr-x. 1 root root 119248 dic  7  2015 /usr/lib64/libva.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-tpi.so -> libva-tpi.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-tpi.so.1 -> libva-tpi.so.1.9900.0
 -rwxr-xr-x. 1 root root   6840 dic  7  2015 /usr/lib64/libva-tpi.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-x11.so -> libva-x11.so.1.9900.0
 lrwxrwxrwx. 1 root root     21 jul 12 14:04 /usr/lib64/libva-x11.so.1 -> libva-x11.so.1.9900.0
 -rwxr-xr-x. 1 root root  32984 dic  7  2015 /usr/lib64/libva-x11.so.1.9900.0

#### Ejemplos del SDK

Nota: Esta sección debería conseguir que puedas instalar los ejemplos para comprobar que la transcodificación por HW funciona. Por desgracia no he conseguido que me funcione, dejo la documentación de todas formas. En mi caso lo ignoré y salté a instalar Tvheadend.

\# yum install -y gcc g++ make cmake perl libX11-devel mesa-libGL-devel

COMO LUIS
 $ mkdir /MSS
 $ cd /MSS
 $ git clone https://github.com/Intel-Media-SDK/samples.git
 $ cd /MSS/samples/samples
 $ export MFX\_HOME=/opt/intel/mediasdk/
 $ perl build.pl --cmake=intel64.make.release --build --clean

$ ls -al \_\_cmake/intel64.make.release/\_\_bin/release/
 total 2024
 drwxrwxr-x. 2 luis luis   4096 jul 12 15:32 .
 drwxrwxr-x. 3 luis luis     20 jul 12 15:32 ..
 -rwxrwxr-x. 1 luis luis 202597 jul 12 15:32 libsample\_plugin\_opencl.so
 -rwxrwxr-x. 1 luis luis 140752 jul 12 15:32 libsample\_rotate\_plugin.so
 -rw-rw-r--. 1 luis luis   3976 jul 12 15:32 ocl\_rotate.cl
 -rwxrwxr-x. 1 luis luis 409959 jul 12 15:32 sample\_decode
 -rwxrwxr-x. 1 luis luis 417292 jul 12 15:32 sample\_encode
 -rwxrwxr-x. 1 luis luis 526198 jul 12 15:32 sample\_multi\_transcode
 -rwxrwxr-x. 1 luis luis 355758 jul 12 15:32 sample\_vpp

PROBAR
 \[root@marte ~\]# cd /MSS/samples/samples/\_\_cmake/intel64.make.release/\_\_bin/release/
 \[root@marte release\]# wget http://download.openbricks.org/sample/H264/big\_buck\_bunny\_1080p\_H264\_AAC\_25fps\_7200K.MP4
 \[root@marte release\]# mv big\_buck\_bunny\_1080p\_H264\_AAC\_25fps\_7200K.MP4 test.mp4
 \[root@marte release\]# ./sample\_multi\_transcode -i::h264 test.mp4 -o::h264 test\_out.mp4 -hw

DA ERROR y NO CONSIGO AVANZAR... !!!!! IGNORO LOS SAMPLES Y PASO A tvheadend...

#### Instalo Tvheadend

Preparo dependencias

\# yum install -y openssl openssl-devel uriparser-devel dbus dbus-devel
 # yum -y install epel-release
 # yum -y install htop
 # yum install -y intel-gpu-tools

# cd
 # git clone https://github.com/tvheadend/tvheadend.git
 # cd tvheadend

# ./configure --prefix=/usr --build=x86\_64-pc-linux-gnu --host=x86\_64-pc-linux-gnu --mandir=/usr/share/man --infodir=/usr/share/info --datadir=/usr/share --sysconfdir=/etc --localstatedir=/var/lib --libdir=/usr/lib64 --prefix=/usr --datadir=/usr/share --enable-qsv
 Checking support/features
 checking for cc execinfo.h ...                    ok
 checking for cc -mmmx ...                         ok
 checking for cc -msse2 ...                        ok
 checking for cc -Wunused-result ...               ok
 checking for cc getloadavg ...                    ok
 checking for cc atomic64 ...                      ok
 checking for cc atomic\_time\_t ...                 ok
 checking for cc lockowner ...                     ok
 checking for cc qsort\_r ...                       ok
 checking for cc stime ...                         ok
 checking for cc gmtoff ...                        ok
 checking for cc recvmmsg ...                      ok
 checking for cc sendmmsg ...                      ok
 checking for cc libiconv ...                      fail
 checking for cc libdvben50221 ...                 fail
 checking for cc ifnames ...                       ok
 checking for py module gzip ...                   ok
 checking for pkg-config ...                       ok
 checking for xgettext ...                         ok
 checking for msgmerge ...                         ok
 checking for gzip ...                             ok
 checking for bzip2 ...                            ok
 checking for pkg openssl  ...                     ok (detected 1.0.1e)
 checking for cc linux/dvb/version.h ...           ok
 checking for pkg zlib  ...                        ok (detected 1.2.7)
 checking for pkg liburiparser  ...                ok (detected 0.7.5)
 checking for pkg avahi-client  ...                ok (detected 0.6.31)
 checking for cmake ...                            ok
 checking for cc -lstdc++ ...                      ok
 checking for cc nvEncodeAPI.h ...                 fail
 checking for autoreconf ...                       ok
 checking for libtool ...                          ok
 checking for libtoolize ...                       ok
 checking for cc -lstdc++ ...                      ok
 checking for pkg libva >=0.38.0 ...               ok (detected 0.99.0)
 checking for pkg libva-x11 >=0.38.0 ...           ok (detected 0.99.0)
 checking for pkg libva-drm >=0.38.0 ...           ok (detected 0.99.0)
 checking for cc sys/inotify.h ...                 ok
 fetching dvb-scan files ...                       ok
 checking for pkg dbus-1  ...                      ok (detected 1.6.12)

Compiler:
 Using C compiler:                        cc
 Build for arch:                          x86\_64

Binaries:
 Using PYTHON:                            python
 Using GZIP:                              gzip
 Using BZIP2:                             bzip2

Options:
 pie                                      yes
 ccdebug                                  no
 cwc                                      yes
 capmt                                    yes
 constcw                                  yes
 linuxdvb                                 yes
 satip\_server                             yes
 satip\_client                             yes
 hdhomerun\_client                         yes
 hdhomerun\_static                         yes
 iptv                                     yes
 tsfile                                   yes
 dvbscan                                  yes
 timeshift                                yes
 trace                                    yes
 imagecache                               yes
 avahi                                    yes
 zlib                                     yes
 libav                                    yes
 ffmpeg\_static                            yes
 libx264                                  yes
 libx264\_static                           yes
 libx265                                  yes
 libx265\_static                           yes
 libvpx                                   yes
 libvpx\_static                            yes
 libtheora                                yes
 libtheora\_static                         yes
 libvorbis                                yes
 libvorbis\_static                         yes
 libfdkaac                                yes
 libfdkaac\_static                         yes
 nvenc                                    no
 qsv                                      yes
 libmfx\_static                            yes
 inotify                                  yes
 epoll                                    yes
 uriparser                                yes
 ccache                                   no
 tvhcsa                                   yes
 bundle                                   no
 dvbcsa                                   no
 dvben50221                               no
 kqueue                                   no
 dbus\_1                                   yes
 android                                  no
 tsdebug                                  no
 gtimer\_check                             no
 slow\_memoryinfo                          no
 libsystemd\_daemon                        no
 bintray\_cache                            yes
 execinfo                                 yes
 mmx                                      yes
 sse2                                     yes
 W\_unused\_result                          yes
 getloadavg                               yes
 atomic64                                 yes
 atomic\_time\_t                            yes
 lockowner                                yes
 qsort\_r                                  yes
 stime                                    yes
 gmtoff                                   yes
 recvmmsg                                 yes
 sendmmsg                                 yes
 ifnames                                  yes
 py\_gzip                                  yes
 bin\_pkg\_config                           yes
 bin\_xgettext                             yes
 bin\_msgmerge                             yes
 bin\_gzip                                 yes
 bin\_bzip2                                yes
 ssl                                      yes
 linuxdvbapi                              yes
 upnp                                     yes
 bin\_cmake                                yes
 stdcpp                                   yes
 libogg\_static                            yes
 bin\_autoreconf                           yes
 bin\_libtool                              yes
 bin\_libtoolize                           yes
 vaapi                                    yes
 inotify\_h                                yes
 mpegts                                   yes
 mpegts\_dvb                               yes

Packages:
 openssl                                  1.0.1e
 zlib                                     1.2.7
 liburiparser                             0.7.5
 avahi-client                             0.6.31
 libva                                    0.99.0
 libva-x11                                0.99.0
 libva-drm                                0.99.0
 dbus-1                                   1.6.12

Installation paths:
 Prefix:                                  /usr
 Binaries:                                ${prefix}/bin
 Libraries:                               /usr/lib64
 Data files:                              /usr/share
 Man pages:                               /usr/share/man

Final Binary:
 /root/src/tvheadend/build.linux/tvheadend

Tvheadend Data Directory:
 /usr/share/tvheadend

- Añado el usuario "tvheadend"

\# useradd -d /home/tvheadend -g video -m -s /usr/bin/bash tvheadend

- Copio el directorio de configuración.En otro sistema tenía instalado Tvheadend y configurado en /etc/tvheadend, lo que hago es copiarme el directorio de configuración para evitar configurarlo desde cero.

FUENTE:
 cd /etc
 tar czf /tmp/tvheadend.tgz tvheadend

DESTINO
 scp luis@fuente:/tmp/tvheadend.tgz /tmp
 cd /etc
 tar xzf /tmp/tvheadend.tgz
 chown -R tvheadend:video tvheadend

- DESACTIVO EL FIREWALL DE CENTOS, viene activo por defecto

\# systemctl disable firewalld
 rm '/etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service'
 rm '/etc/systemd/system/basic.target.wants/firewalld.service'
# systemctl stop firewalld

- ARRANCO TVHEADEND en un termimal

\# /usr/bin/tvheadend -C -u tvheadend -g video -c /etc/tvheadend

- ARRANCO intel\_gpu\_top en otro terminal

\# intel\_gpu\_top

- ARRANCO htop en otro terminal

\# htop

[![centosqsv](https://www.luispa.com/wp-content/uploads/2016/07/centosqsv-1024x563.jpg)](https://www.luispa.com/wp-content/uploads/2016/07/centosqsv.jpg)

- Pendientes de investigar
    - Nota1: No he aplicado ningún parche tal como se menciona aquí: https://tvheadend.org/issues/3080
    - Nota2: No he aplicado el Fork TheTroll: https://github.com/TheTroll/tvheadend

* * *

* * *

 

 

 

## Enlaces

Enlaces relacionados con este apunte:

- [Subsistema de aceleración HW de FFMPEG](https://trac.ffmpeg.org/wiki/HWAccelIntro)
- [VA API (Video Acceleration API)](https://en.wikipedia.org/wiki/VA_API) ofrece acceso al hardware gráfico (GPU) para procesamiento de video
- [INTEL: Página de descarga del "Intel® Media Server Studio – Community Edition"](https://registrationcenter.intel.com/download.aspx?productid=2813&pass=yes)
    - Es necesario que estes registrado, podrása bajarte el Intel® Media Server Studio for Linux,
- [INTEL: Open Source - Intel Media SDK Dispatcher (lu-zero/mfx\_dispatch)](https://github.com/lu-zero/mfx_dispatch)
- [INTEL: Información - Intel Graphic Stack para diferentes plataformas](https://01.org/linuxgraphics)
- [INTEL: Driver Intel para VAAPI](https://cgit.freedesktop.org/vaapi/intel-driver/)
- [Gentoo: Driver "**Intel**" open source para tener acceso a la tarjeta gráfica de los NUC](https://wiki.gentoo.org/wiki/Intel)
    - Necesario para montar un entorno X11 acelerado.
    - Incluye una lista interesante de generaciones de tarjetas gráficas que Intel incluye en sus procesadores.
    - Describe modificaciones en el Kernel para acceder a la tarjeta gráfica Intel y usar su driver
- [Gentoo: VAAPI](https://wiki.gentoo.org/wiki/VAAPI)
    - Describe cómo activar VAAPI (Video Acceleration API) en un equipo con Gentoo.
- [Gentoo: Enable hardware H264 decoding on Intel G/GM45](https://wiki.gentoo.org/wiki/Enable_hardware_H264_decoding_on_Intel_G/GM45)
    - Al usar VAAPI solo se pueden decodificar **en hardware** streams de video MPEG-2 en los chipsets intel G/GM45. En este enlace se habilita la decodificación (experimental) de H.264/AVC en hardware.

Discusiones relevantes en el foro de Tvheadend

- [Primera (aunque algo desactualizada) https://tvheadend.org/issues/3080](https://tvheadend.org/issues/3080). Aquí se habla de los parches para Kernels 3 y 4.1.
    - Versión de prueba de LuisPa de los [parches para Kernel 4.6 (ojo todavía no me funcionan)](https://github.com/LuisPalacios/tvh_qsv)
- [Segunda (más interesante y actualizada) https://tvheadend.org/issues/3831](https://tvheadend.org/issues/3831)

Herramientas

- [mpv, un media player ligero basado en MPlayer](https://wiki.archlinux.org/index.php/mpv). Por si montas el Linux con X11 y necesitas uno reproductor de video ligero.
