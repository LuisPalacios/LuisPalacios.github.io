---
title: "¬°Adi√≥s Bash, hola Zsh!"
date: "2024-04-27"
categories: administraci√≥n
tags: zsh macos linux tmux desarrollo terminal homebrew
excerpt_separator: <!--more-->
---

![logo user](/assets/img/posts/logo-zsh.svg){: width="150px" height="150px" style="float:left; padding-right:25px" }

He decidido migrar todos mis sistemas Linux de la fiable y conocida *`bash`* a la poderosa y vers√°til *`zsh`*. Se trata de una evoluci√≥n extendida de la Bourne Shell (sh), no solo hereda muchas de las caracter√≠sticas familiares de Bash, sino que tambi√©n introduce una serie de nuevas funcionalidades y ofrece un s√≥lido soporte para plugins y temas personalizados. Apple adopt√≥ Zsh como la shell predeterminada hace alg√∫n tiempo, me faltaba dar el paso en mis sistemas Linux.

<br clear="left"/>
<!--more-->

## ¬øPor qu√© Zsh?

Antes de sumergirnos en la instalaci√≥n y configuraci√≥n de Zsh, es esencial comprender las razones detr√°s de esta elecci√≥n. **Zsh**, abreviatura de "Z Shell", es una potente shell de Unix que ofrece numerosas mejoras y funcionalidades sobre Bash, la shell predeterminada en muchos sistemas Unix.

Ventajas de Zsh sobre Bash

- *Autocompletado Avanzado*: Zsh brinda un autocompletado inteligente y avanzado que supera con creces las capacidades de Bash. Desde la sugerencia de nombres de archivos hasta completar comandos y argumentos, la experiencia de navegaci√≥n en la l√≠nea de comandos se vuelve m√°s fluida y eficiente.

- *Personalizaci√≥n Extensiva*: Zsh permite una personalizaci√≥n profunda y flexible de la interfaz de usuario. Los usuarios pueden elegir entre una amplia gama de temas predefinidos o crear sus propios dise√±os para adaptar la apariencia de la l√≠nea de comandos a sus preferencias individuales.

- *Potentes Extensiones y Plugins*: La comunidad de Zsh ofrece una gran cantidad de extensiones y plugins que ampl√≠an a√∫n m√°s su funcionalidad. Desde la integraci√≥n con herramientas de desarrollo hasta la gesti√≥n avanzada de historiales de comandos, estas extensiones permiten a los usuarios personalizar su entorno de trabajo de acuerdo con sus necesidades espec√≠ficas.

- *Historial Mejorado*: Zsh proporciona un historial de comandos mejorado que facilita la b√∫squeda, edici√≥n y ejecuci√≥n de comandos anteriores. Esta caracter√≠stica resulta especialmente √∫til para usuarios que trabajan con una gran cantidad de comandos en su d√≠a a d√≠a.

<br/>

## Instalaci√≥n

### Linux (Ubuntu)

En sistemas Linux basados en Debian, como Ubuntu, la instalaci√≥n de Zsh es sencilla. Puedes comprobar si ya est√° instalado y en su defecto instalar Zsh:

```zsh
‚ö° luis@luix:~ $ sudo dpkg -l zsh
:
‚ö° luis@luix:~ $ apt install zsh
```

Compruebo que es una shell v√°lida:

```zsh
‚ö° luis@luix:~ $ grep zsh /etc/shells`
/bin/zsh
/usr/bin/zsh
```

Cambio a Zsh, para `luis` y `root` con `chsh -s $(which zsh)`

```zsh
‚ö° luis@luix:~ $ chsh -s $(which zsh)
Contrase√±a:
‚ö° luis@luix:~ $
‚ö° luis@luix:~ $ sudo su -
Contrase√±a:
root@luix:~# chsh -s $(which zsh)
root@luix:~#
```

Salgo y vuelvo a entrar en ambos usuarios y verifico que se ejecuta zsh.

```zsh
‚ö° luis@luix:~ $ ps
    PID TTY          TIME CMD
  48727 pts/0    00:00:00 zsh   <=== !!
  48736 pts/0    00:00:00 ps
```

- Si no tienes el fichero `.zshrc` probalemente se ejecutar√° `zsh-newuser-install` y te ofrecer√° crearlo. En mi caso seleccion√© la opci√≥n *(2) Populate your ~/.zshrc with the configuration recommended*. Cre√≥ este fichero `.zshrc` por defecto:

- Crea el fichero .zshrc por defecto. En mi caso le he hecho unas cuantas modificaciones que dejo aqu√≠ a modo de ejemplo

```zsh
# zshrc LuisPa 2024
#

# LuisPa: -------------------------------------------------------------- START
#
# Probado: 
# linux, normal user and root - OK
# macos normal user - OK
# macos root doesn't use zsh but /bin/sh (a gnu bash special version), consumes /root.lprofile
#
# Ideas & code taken from: 
# My .zshrc -> https://github.com/vincentbernat/zshrc
#if [[ ! -a ~/.zsh ]]; then
#  git clone --recurse-submodules git@github.com:LuisPalacios/zshrc.git ~/.zsh
#fi
# ASYNC     -> https://github.com/mafredri/zsh-async
#

# Para debug
#NORMAL="\033[0;39m"
#ROJO="\033[1;31m"
#VERDE="\033[1;32m"
#AMARILLO="\033[1;33m"
#AZUL="\033[1;34m"

# Detectar si estoy dentro de una sesi√≥n VSCODE
export IS_VSCODE=false
if [[ $(printenv | grep -c "VSCODE_") -gt 0 ]]; then
    export IS_VSCODE=true
fi

# Personalizaci√≥n de los colores del tree de GNU
export TREE_COLORS=${LS_COLORS//04;}

# Personalizaci√≥n de los colores del comando 'ls'
# LS_COLORS se usan en ls de GNU,
export LS_COLORS='fi=00:mi=00:mh=00:ln=01;94:or=01;31:di=01;36:ow=04;01;34:st=34:tw=04;34:'
LS_COLORS+='pi=01;33:so=01;33:do=01;33:bd=01;33:cd=01;33:su=01;35:sg=01;35:ca=01;35:ex=01;32'
LS_COLORS+=':*.cmd=00;32:*.exe=01;32:*.com=01;32:*.bat=01;32:*.btm=01;32:*.dll=01;32'
LS_COLORS+=':*.tar=00;31:*.tbz=00;31:*.tgz=00;31:*.rpm=00;31:*.deb=00;31:*.arj=00;31'
LS_COLORS+=':*.taz=00;31:*.lzh=00;31:*.lzma=00;31:*.zip=00;31:*.zoo=00;31:*.z=00;31'
LS_COLORS+=':*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.tb2=00;31:*.tz2=00;31:*.tbz2=00;31'
LS_COLORS+=':*.avi=01;35:*.bmp=01;35:*.fli=01;35:*.gif=01;35:*.jpg=01;35:*.jpeg=01;35'
LS_COLORS+=':*.mng=01;35:*.mov=01;35:*.mpg=01;35:*.pcx=01;35:*.pbm=01;35:*.pgm=01;35'
LS_COLORS+=':*.png=01;35:*.ppm=01;35:*.tga=01;35:*.tif=01;35:*.xbm=01;35:*.xpm=01;35'
LS_COLORS+=':*.dl=01;35:*.gl=01;35:*.wmv=01;35'
# mientras que LSCOLORS se usa en el ls de BSD
export CLICOLOR=1
export LSCOLORS='GxExDxDxCxDxDxFxFxexEx'

# No poner l√≠neas de comando en la lista de historial si son duplicados
setopt HIST_IGNORE_DUPS
# Comparte el historial entre todas las instancias
setopt SHARE_HISTORY
# Que no pida Y/N cuando se hace un rm -fr
setopt RM_STAR_SILENT
# Habilitar expansi√≥n de par√±ametros en el prompt, necesario para
# mostrar informaci√≥n de branches de Git por ejemplo.
setopt PROMPT_SUBST

# Use emacs keybindings even if our EDITOR is set to vi
bindkey -e

# Keep 1000 lines of history within the shell and save it to ~/.zsh_history:
HISTSIZE=1000
SAVEHIST=1000
HISTFILE=~/.zsh_history

# Use modern completion system
autoload -Uz compinit
compinit
zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select=2
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
zstyle ':completion:*' menu select=long
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' use-compctl false
zstyle ':completion:*' verbose true
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'
zstyle ':completion:*' list-colors "${(@s.:.)LS_COLORS}"

# Permitir ganchos en diferentes puntos de la ejecuci√≥n del shell,
# como antes o despu√©s de un comando, permitiendo a los usuarios o scripts
# a√±adir comportamientos personalizados en estos puntos.
autoload -Uz add-zsh-hook

# Async helpers
#
_vbe_vcs_async_start() {
    async_start_worker vcs_info
    async_register_callback vcs_info _vbe_vcs_info_done
}
_vbe_vcs_info() {
    cd -q $1
    vcs_info
    print ${vcs_info_msg_0_}
}
_vbe_vcs_info_done() {
    local job=$1
    local return_code=$2
    local stdout=$3
    local more=$6
    if [[ $job == '[async]' ]]; then
        if [[ $return_code -eq 2 ]]; then
            # Need to restart the worker. Stolen from
            # https://github.com/mengelbrecht/slimline/blob/master/lib/async.zsh
            _vbe_vcs_async_start
            return
        fi
    fi
    vcs_info_msg_0_=$stdout
    (( $more )) || zle reset-prompt
}
_vbe_vcs_chpwd() {
    vcs_info_msg_0_=
}
_vbe_vcs_precmd() {
    async_flush_jobs vcs_info
    async_job vcs_info _vbe_vcs_info $PWD
}

# PROMPT con vcs_info
#
# 1. Habilito vcs_info y prompt_subst
autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:*+*:*' debug false
#setopt prompt_subst # Enable prompt substitution

# 2. Estados y variables, 5 posibles estados: 
# Ver https://github.com/zsh-users/zsh/blob/master/Functions/VCS_Info/Backends/VCS_INFO_get_data_git
# lp_gituntracked  - true si hay algo en la WORKING area PENDIENTE DE STAGING (add) - COLOR BLUE
# gitstaged - de vcs_info, true si hay contenido en la staging area PENDIENTE DE COMMIT - COLOR GREEN
# gitunstaged - de vcs_info, true si se modific√≥ en working y est√° PENDIENTE DE STAGING (add) - COLOR ROJO
# lp_gitunpushed - true si hay contenido PENDIENTE DE PUSH al origin - COLOR YELLOW/ORANGE
# Resto ... si todas las demas son falsas - COLOR BLANCO
lp_gituntrackedstr='%{%F{blue}%B%}‚óè%{%b%f%}'
zstyle ':vcs_info:*' stagedstr '%{%F{green}%B%}‚óè%{%b%f%}' # '+' # ver gitstaged, hay contenido en la staging area PENDIENTE DE COMMIT
zstyle ':vcs_info:*' unstagedstr '%{%F{red}%B%}‚óè%{%b%f%}' # 'U' # ver gitunstaged, se modific√≥ en working y est√° PENDIENTE DE STAGING
lp_gitunpushedstr='%{%F{yellow}%B%}‚óè%{%b%f%}'

# 3. Preparo "formats" de la informaci√≥n vcs_info
#
# General Placeholders
# %b: Displays the current branch name.
# %c: Shows the number of changes that have been staged (added to the index) but not yet committed.
# %u: Indicates the number of unstaged changes.
# %r: Represents the name of the repository.
# %R: Provides the root directory of the repository.
# %s: The name of the VCS system in use (e.g., git, svn).
# %S: Shorthand for the VCS system name.
# %m: Displays the name of the current VCS action or mode (like REBASE, MERGE).
# %a: Shows the number of commits your repository is ahead of the tracked remote branch.
# %d: Indicates if there are any 'dirty' files (modified files).
# %i: Custom information that can be defined by specific vcs_info hooks or extensions.
# %I: Similar to %i but intended for more compact or alternate displays.
# %p: Shows the current patch or revision number.
# %P: Similar to %p but tailored for shorter displays.
# %n: Indicates the number of patches or revisions applied from a series.
# %N: A compact version of %n.
# %x: Used to display a user-defined message or data, often set in hooks.
# %X: Similar to %x but intended for alternate or additional user-defined data.
# %z: Typically used to show the state of a repository, such as whether it's in a bisect state.
# %Z: Can be used for a more detailed description of the repository state.
#
#¬†Formatting and Conditional Modifiers
#¬†%F{color} and %f: These are used to set the foreground color. %F{color} starts the color display, where color can be a name like red, green, blue, etc., or a numeric color code. %f resets the foreground color to the default terminal color.
#¬†%K{color} and %k: Similar to %F and %f, but for the background color. %K{color} starts the background color, and %k resets it.
#¬†%B and %b: Turn bold text on and off, respectively. %B enables bold formatting, and %b disables it.
#¬†%U and %u: Control underline formatting. %U turns on underlining, and %u turns it off.
# %{...%}: Used to include literal escape sequences or to apply formatting codes 
#         ¬†that do not consume physical space on the terminal. This is critical for color 
#¬†         codes or cursor movements that should not affect the width calculations of your prompt.
#
# Conditional modifiers
#¬†%(!.primary.secondary): Displays primary if the shell is running with privileges (e.g., root user), and secondary otherwise. Useful for changing prompt elements based on user privileges.
#¬†%(x.true.false): A conditional format that evaluates x (a shell parameter or state) and displays true if x is non-zero or non-empty, and false otherwise.
#
# Truncation and Padding
# ?
# 
#zstyle ':vcs_info:*' formats " %F{cyan}%c%u(%b)%f" # formato del prompt cuando se est√° dentro de un repositorio
#zstyle ':vcs_info:*' formats ' (%b)-%u-%c-'
zstyle ':vcs_info:*' formats ' (%u%c%b%%b%f'

# 4. Preparo "actionformats" (NO PROBADO)
zstyle ':vcs_info:*' actionformats "A %F{cyan}%c%u(%b)%f %a" # Similar al anterior pero para acciones espec√≠ficas (por ejemplo, durante un rebase)

# 5. Programar hooks
zstyle ':vcs_info:git*+set-message:*' hooks git-check-status
zstyle ':vcs_info:*+set-message:*' hooks home-path
function +vi-home-path() {
  # Replace $HOME with ~
  hook_com[base]="$(echo ${hook_com[base]} | sed "s/${HOME:gs/\//\\\//}/~/" )"
}
function __git_symbols() {
	# Symbols
	local ahead='‚Üë'         # '‚Üë' 'üî∫'
	local behind='‚Üì'        # '‚Üì' 'üîª'
	local diverged='‚Üï'      # '‚Üï' '‚ô¶Ô∏è' 'üÜò'
	#local up_to_date='|'    # '|' '‚úÖ'
	local no_remote='o'     # 'o' '‚≠ï'
	local staged='+'        # '+' 'üìó'
	local untracked='?'     # '?' '‚ùì'
	local modified='!'      # '!' '‚ùó' 
	local moved='>'          # '>' '‚û°Ô∏è'
	local deleted='x'       # 'x' '‚ùå'
	local stashed='$'       # '$' 'üì§'

	local output_symbols=''

	local git_status_v
	git_status_v="$(git status --porcelain=v2 --branch --show-stash 2>/dev/null)"

	# Parse de la informaci√≥n del branch
  local ahead_count behind_count

	# AHEAD, BEHIND, DIVERGED
	if echo $git_status_v | grep -q "^# branch.ab " ; then
		# One line of the git status output looks like this:
		# # branch.ab +1 -2
		# In the line below:
		# - we grep for the line starting with # branch.ab
		# - we grep for the numbers and output them on separate lines
		# - we remove the + and - signs
		# - we put the two numbers into variables, while telling read to use a newline as the delimiter for reading
		read -d "\n" -r ahead_count behind_count <<< $(echo "$git_status_v" | grep "^# branch.ab" | grep -o -E '[+-][0-9]+' | sed 's/[-+]//')
		# Show the ahead and behind symbols when relevant
		[[ $ahead_count != 0 ]] && output_symbols+="$ahead"
		[[ $behind_count != 0 ]] && output_symbols+="$behind"
		# Replace the ahead symbol with the diverged symbol when both ahead and behind
		output_symbols="${output_symbols//$ahead$behind/$diverged}"

		# If the branch is up to date, show the up to date symbol
		#[[ $ahead_count == 0 && $behind_count == 0 ]] && output_symbols+="$up_to_date"
	fi

	# STASHED
	echo $git_status_v | grep -q "^# stash " && output_symbols+="$stashed"

	# STAGED
	[[ $(git diff --name-only --cached) ]] && output_symbols+="$staged"

	# For the rest of the symbols, we use the v1 format of git status because it's easier to parse.
	local git_status

	symbols="$(git status --porcelain=v1 | cut -c1-2 | sed 's/ //g')"

	while IFS= read -r symbol; do
		case $symbol in
			??) output_symbols+="$untracked";;
			M) output_symbols+="$modified";;
			R) output_symbols+="$moved";;
			D) output_symbols+="$deleted";;
		esac
	done <<< "$symbols"

	# Remove duplicate symbols
	output_symbols="$(echo -n "$output_symbols" | tr -s "$untracked$modified$moved$deleted")"

	[[ -n $output_symbols ]] && echo -n "$output_symbols"
}
# Function to display Git status with symbols
function __git_info() {
	local git_info=''
	local git_branch_name=''

	if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
		# Get the Git branch name
		#git_branch_name="$(git symbolic-ref --short HEAD 2>/dev/null)"
		#if [[ -n "$git_branch_name" ]]; then
	  #  git_info+="$git_branch_name"
		#fi
		# Get the Git status
		git_info+="$(__git_symbols)"
    if [[ "$git_info" != "" ]]; then 
      echo " $git_info)" 
    else
      echo ")" 
    fi
	fi
}

# Funci√≥n para ver el estado de mi rama git
+vi-git-check-status(){

  # Check pending push, when we are ahead of remote.
  if [[ "$(git rev-parse --quiet --verify HEAD 2> /dev/null)" && \
        "$(git status --branch --short | head -n1 | grep ahead 2> /dev/null)" ]]; then
      lp_gitunpushed=1
      hook_com[staged]+=${lp_gitunpushedstr}
  else
      lp_gitunpushed=
  fi
  
  # Check untracked, when we untracked (not added) files or directories in our working area 
  if [[ ( "$(git rev-parse --is-inside-work-tree 2> /dev/null)" == "true" && \
        "$(git status --porcelain 2> /dev/null | grep -q '^?? ')" != "" ) || \
      "$(git ls-files --other --directory --exclude-standard 2> /dev/null | wc -l | tr -d ' ')" -gt 0 ]]; then
      lp_gituntracked=1
      hook_com[unstaged]="${lp_gituntrackedstr}${hook_com[unstaged]}"
  else
      hook_com[untracked]=''
      lp_gituntracked=
  fi


  ##  echo "Debug ---"
  #[[ ${querystaged} -eq 0 ]] && { echo "Querystaged: X";:; } || { echo "querystaged: ${AMARILLO}yes${NORMAL}" ; }
  #[[ ${git_patches_applied} -eq 0 ]] && { echo "git_patches_applied: X";:; } || { echo "git_patches_applied: ${AMARILLO}yes${NORMAL}" ; }
  #[[ ${git_patches_unapplied} -eq 0 ]] && { echo "git_patches_unapplied: X";:; } || { echo "git_patches_unapplied: ${AMARILLO}yes${NORMAL}" ; }
  #[[ ${gitaction} -eq 0 ]] && { echo "gitaction: X";:; } || { echo "gitaction: ${AMARILLO}yes${NORMAL}" ; }
  #[[ ${gitmisc} -eq 0 ]] && { echo "gitmisc: X";:; } || { echo "gitmisc: ${AMARILLO}yes${NORMAL}" ; }
  #[[ ${gitsha1} -eq 0 ]] && { echo "gitsha1: X";:; } || { echo "gitsha1: ${AMARILLO}yes${NORMAL}" ; }
  #[[ ${lp_gituntracked} -eq 0 ]] && { echo "Untracked: X";:; } || { echo "Untracked: ${AZUL}‚óè${NORMAL}" ; }
  #[[ ${gitunstaged} -eq 0 ]] && { echo "Unstaged: X";:; } || { echo "Unstaged: ${ROJO}‚óè${NORMAL}" ; }
  #[[ ${gitstaged} -eq 0 ]] && { echo "Staged: X";:; } || { echo "Staged: ${VERDE}‚óè${NORMAL}" ; }
  #[[ ${lp_gituntracked} -eq 0 ]] && { echo "Untracked: X";:; } || { echo "Untracked: ${AZUL}‚óè${NORMAL}" ; }
  #echo "----"

  # Precolor
  if [[ ${lp_gitunpushed} -ne 0 ]]; then
    hook_com[staged]+="%B%F{yellow} "
  elif [[ ${gitunstaged} -ne 0 ]]; then
    hook_com[staged]+="%B%F{red} "
  elif [[ ${gitstaged} -ne 0 ]]; then
    hook_com[staged]+="%B%F{green} "
  elif [[ ${lp_gituntracked} -ne 0 ]]; then
    hook_com[staged]+="%B%F{cyan} "
  fi

}

# Asynchronous VCS status
source ~/.zshrc.async
async_init
_vbe_vcs_async_start
add-zsh-hook precmd _vbe_vcs_precmd
add-zsh-hook chpwd _vbe_vcs_chpwd

# Add VCS information to the prompt
_vbe_add_prompt_0vcs () {
    _vbe_prompt_segment cyan default ${vcs_info_msg_0_}
}

# Par√°metros para la construcci√≥n del prompt
#
# Basic Components of Format Strings
# %b: Branch name. Displays the name of the current branch.
# %c: Number of commits ahead of remote.
# %u: Number of commits behind remote.
# %a: Action. This shows the current action, like 'MERGING', 'REBASING', etc.
# %r: Repository name. This is useful when working in a repo that's nested inside another.
# %R: Root directory of the repository. This shows the path to the top level of the repository.
# %s: Stash. This shows the number of stashes.
# %m: Whether the repo is "modified."
# %i: Information on whether there are staged changes.
# %I: More detailed information on the index state (staged changes).
# %n: Name of the repository if set.
# 
# Use of Formatting Codes
# %F{color}: Sets the foreground color of the subsequent text (until %f or another %F is encountered). For example, %F{red} makes the text red.
# %f: Resets the foreground color to the default.
# %B: Start bold text.
# %b: Stop bold text.
# %U: Start underlined text.
# %u: Stop underlined text.
#

# Parametrizo seg√∫n OS
#
# Funci√≥n para averiguar la opci√≥n de usar colores en el comando ls
function test-ls-args {
  local cmd="$1"          # ls, gls, colorls, ...
  local args="${@[2,-1]}" # los argumentos excepto el primero
  command "$cmd" "$args" /dev/null &>/dev/null
}

# Parametrizaciones seg√∫n el OS
case "$OSTYPE" in

  # NetBSD
  netbsd*)
    # On NetBSD, test if `gls` (GNU ls) is installed (this one supports colors);
    # otherwise, leave ls as is, because NetBSD's ls doesn't support -G
    test-ls-args gls --color && alias ls='gls --color=tty'
    ;;

  # OpenBSD
  openbsd*)
    # On OpenBSD, `gls` (ls from GNU coreutils) and `colorls` (ls from base,
    # with color and multibyte support) are available from ports.
    # `colorls` will be installed on purpose and can't be pulled in by installing
    # coreutils (which might be installed for ), so prefer it to `gls`.
    test-ls-args gls --color && alias ls='gls --color=tty'
    test-ls-args colorls -G && alias ls='colorls -G'
    ;;

  # MacOS
  (darwin|freebsd)*)
    # This alias works by default just using $LSCOLORS
    test-ls-args ls -G && alias ls='ls -G'
    # Only use GNU ls if installed and there are user defaults for $LS_COLORS,
    # as the default coloring scheme is not very pretty
    zstyle -t ':omz:lib:theme-and-appearance' gnu-ls \
      && test-ls-args gls --color \
      && alias ls='gls --color=tty'

    # Deshabilito FLOW CONTROL en mi terminal para que CTRL-S, CTRL-Q funcionen normales
    stty -ixon

    # Mi PROMPT
    PROMPT='üçè %F{green}%B%n%b@%F{yellow}%m%f:%B%F{cyan}%1~%f%b${vcs_info_msg_0_}$(__git_info) %# '

    # PATH
    export PATH=.:$HOME/Nextcloud/priv/bin:/usr/local/bin:/usr/local/sbin:$PATH
    launchctl setenv PATH "/usr/local/bin:/usr/local/sbin:$PATH"

    # Homebrew
    eval "$(/opt/homebrew/bin/brew shellenv)"                                          # Homebrew en Mac ARM
    #eval "$(/usr/local/bin/brew shellenv)"                                            # Homebrew en Mac Intel
    # Ruby y Gems
    export PATH="/opt/homebrew/opt/ruby/bin:~/.gems/bin:$PATH"   # Versi√≥n para Mac ARM
    #export PATH="/usr/local/opt/ruby/bin:~/.gems/bin:$PATH"     # Versi√≥n para Mac Intel

    # Las "gems" de Ruby se instalar√°n en ~/.gems
    export GEM_HOME=~/.gems
    export PATH=~/.gems/bin:$PATH

    # C y C++
    export CPLUS_INCLUDE_PATH=/usr/local/include
    export LIBRARY_PATH=/usr/local/lib

    # ALIAS
    alias grep="/usr/bin/grep -d skip"
    alias e="/usr/local/bin/code"
    alias python="/opt/homebrew/bin/python3"
    alias pip="/opt/homebrew/bin/pip3"

    # Acelerar la navegaci√≥n en recursos compartidos de red
    (defaults write com.apple.desktopservices DSDontWriteNetworkStores true &)

    # SSH - Lo arranco en el background porque tarda 1 o 2 segundos
    # De esta forma consigo el prompt inmediatamente.
    (ssh-add --apple-load-keychain >/dev/null 2>&1 &)

    ;;
  # Linux
  *)
    if test-ls-args ls --color; then
      alias ls='ls --color=tty'
    elif test-ls-args ls -G; then
      alias ls='ls -G'
    fi

    # Mi PROMPT
    if [[ $EUID -eq 0 ]]; then
      # En el caso de ser root
      PROMPT='[%B%F{white}root%f%b]@%m:%~%# '
    else
      # Mi usuario normal
      PROMPT='‚ö° %F{green}%B%n%b@%m%f:%B%F{cyan}%1~%f%b${vcs_info_msg_0_}$(__git_info) %# '
    fi

    # PATH
    export PATH=.:$HOME/Nextcloud/priv/bin:/usr/local/bin:/usr/local/sbin:$PATH

    ;;
esac

# Locales
export LANG=es_ES.UTF-8
export LC_CTYPE="es_ES.UTF-8"
export LC_NUMERIC="es_ES.UTF-8"
export LC_TIME="es_ES.UTF-8"
export LC_COLLATE="es_ES.UTF-8"
export LC_MONETARY="es_ES.UTF-8"
export LC_MESSAGES="es_ES.UTF-8"
export LC_PAPER="es_ES.UTF-8"
export LC_NAME="es_ES.UTF-8"
export LC_ADDRESS="es_ES.UTF-8"
export LC_TELEPHONE="es_ES.UTF-8"
export LC_MEASUREMENT="es_ES.UTF-8"
export LC_IDENTIFICATION="es_ES.UTF-8"
export LC_ALL="es_ES.UTF-8"

# LuisPa: -------------------------------------------------------------- END
```

||
|-|
| My .zshrc uses ideas and code from: |
| [https://github.com/vincentbernat/zshrc](https://github.com/vincentbernat/zshrc) |
| [https://github.com/mafredri/zsh-async](https://github.com/mafredri/zsh-async) |
||

### macOS

Los usuarios de macOS ya tienen Zsh instalado por defecto, lo que significa que pueden empezar a utilizarlo de inmediato sin necesidad de instalaci√≥n adicional. Pueden abrir Terminal y comenzar a experimentar con las caracter√≠sticas y funcionalidades de Zsh.

### Windows 11

Para los usuarios de Windows 11 que deseen utilizar Zsh, se recomienda instalar el Subsistema de Windows para Linux (WSL) y una distribuci√≥n de Linux compatible. Una vez instalado WSL y la distribuci√≥n de Linux deseada, Zsh se puede instalar desde el gestor de paquetes de la distribuci√≥n de Linux elegida.

## Referencias

### Cheatsheet

En la recomendad√≠sima [Ultimate Resource List](https://gist.github.com/bgoonz/be5c5be77169ef333b431bc37d331176) encontrar√°s una estupenda Cheatsheet. Resalto las entradas relacionadas con `zsh`:

- **Shells**
  - ‚úÖ **Zsh** - es un shell dise√±ado para uso interactivo, aunque tambi√©n es un poderoso lenguaje de scripting.
  - ‚úÖ **Oh My ZSH!** - es el mejor marco de trabajo para gestionar tu configuraci√≥n de Zsh.

- **Plugins para shell**
  - ‚úÖ **zsh-autosuggestions** - Autosugestiones al estilo de Fish para Zsh.
  - ‚úÖ **zsh-syntax-highlighting** - Resaltado de sintaxis al estilo del shell Fish para Zsh.
  - ‚úÖ **Awesome ZSH Plugins** - Una lista de marcos de trabajo, plugins, temas y tutoriales para ZSH.

- **Gestores**
  - ‚úÖ **tmux** - es un multiplexor de terminales, permite cambiar f√°cilmente entre varios programas en un mismo terminal.

<br/>

---

Al hacer la transici√≥n de Bash a Zsh, no solo est√°s adoptando una herramienta m√°s poderosa y vers√°til, sino que tambi√©n est√°s abriendo las puertas a una experiencia en la l√≠nea de comandos m√°s eficiente y adaptable. Con sus caracter√≠sticas avanzadas y su activa comunidad de desarrolladores, Zsh se posiciona como la opci√≥n ideal para usuarios que buscan maximizar su productividad y control en entornos estilo unix.
